package json

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"runtime/debug"
)

func Generate(plugin *protogen.Plugin, cfg *Config) error {
	ctx := Context{Plugin: plugin, Config: cfg}
	return ctx.Generate()
}

type Context struct {
	*protogen.Plugin
	*Config
}

func (c *Context) Generate() error {
	for _, file := range c.Files {
		f := File{File: file}
		err := f.Generate(c)
		if err != nil {
			return err
		}
	}
	return nil
}

type File struct {
	*protogen.File
	*protogen.GeneratedFile
}

func (f *File) Generate(ctx *Context) error {
	if !f.File.Generate {
		return nil
	}
	f.GeneratedFile = ctx.NewGeneratedFile(
		f.GeneratedFilenamePrefix+ctx.Config.FileNameSuffix,
		f.GoImportPath,
	)

	err := f.GenerateFileHead()
	if err != nil {
		return err
	}
	return f.GenerateMessages(ctx)
}

func (f *File) GenerateFileHead() error {
	f.P("// Code generated by protoc-gen-go-json. DO NOT EDIT.")
	if info, ok := debug.ReadBuildInfo(); ok {
		f.P("// protoc-gen-go-json version: ", info.Main.Version)
	}
	f.P("// source: ", f.Desc.Path())
	f.P()
	f.P("package ", f.GoPackageName)
	f.P()

	return nil
}

func (f *File) GenerateMessages(ctx *Context) error {
	for _, msg := range f.File.Messages {
		if msg == nil {
			continue
		}
		err := f.GenerateMessage(ctx, msg)
		if err != nil {
			return err
		}
	}

	return nil
}

func (f *File) GenerateMessage(ctx *Context, msg *protogen.Message) error {
	f.P("// ", msg.Desc.FullName())
	if len(msg.Fields) == 0 {
		f.P("func (", Instance, " *", msg.GoIdent, ") ", ctx.EncodeMethodName, "() ([]byte, error) {")
		f.P("return []byte(\"{}\"),nil")
		f.P("}")
		return nil
	}
	f.P("func (", Instance, " *", msg.GoIdent, ") ", ctx.EncodeMethodName, "() ([]byte, error) {")
	f.P("if ", Instance, " == nil {")
	f.P("return nil,nil")
	f.P("}")
	protoimplPackage := protogen.GoImportPath(ctx.ImportWriter)

	f.P("var ", Buf, " ", protoimplPackage.Ident("Buffer"))
	f.P(Buf, WriteByte, `('{')`)
	size := len(msg.Fields)
	if size > 1 {
		f.P("var ", CommaVarName, " bool")
	}

	for i := 0; i < size; i++ {
		f.P("// go name ", msg.Fields[i].GoName, " : kind ", msg.Fields[i].Desc.Kind())
		oneof := msg.Fields[i].Oneof != nil && !msg.Fields[i].Oneof.Desc.IsSynthetic()
		if oneof {
			i = f.GenerateMessageOneof(ctx, msg.Fields[i], size) - 1
		} else {
			f.P("// number ", msg.Fields[i].Desc.Number())
			f.GenerateMessageField(ctx, msg.Fields[i], size)
		}
	}
	f.P(Buf, WriteByte, `('}')`)
	f.P("return ", Buf, ctx.WriteBytes, ",nil")
	f.P("}")
	f.P()

	return nil
}

func (f *File) GenerateMessageField(ctx *Context, fd *protogen.Field, size int) {
	switch {
	case fd.Desc.IsList():
		f.P("if len(", Instance, ".", fd.GoName, ") > 0 {")
		f.WirteCommaAndTrue(fd)
		f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":[`)")
		f.P("for i,val := range ", Instance, ".", fd.GoName, "{")
		f.P("// ", fd.Desc.Kind())
		f.P(" if i > 0 {")
		f.P(Buf, WriteByte, CommaValue)
		f.P("}")
		_ = HandlerType(ctx, fd.Desc.Kind(), f.GeneratedFile, false, "val")
		f.P("}")
		f.P(Buf, WriteByte, "(']')")
		f.WirteCommaTrue(fd, size)
		f.P("}")
	case fd.Desc.IsMap():
		f.P("if len(", Instance, ".", fd.GoName, ") > 0 {")
		f.WirteCommaAndTrue(fd)
		f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":{`)")
		f.P("var many bool")
		f.P("for key,val := range ", Instance, ".", fd.GoName, "{")
		f.P("// ", fd.Desc.Kind(), ", key ", fd.Desc.MapKey().Kind(), ", value ", fd.Desc.MapValue().Kind())
		f.P("if many {")
		f.P(Buf, WriteByte, CommaValue)
		f.P("} else {")
		f.P("many=true")
		f.P("}")
		_ = HandlerType(ctx, fd.Desc.MapKey().Kind(), f.GeneratedFile, true, "key")
		f.P(Buf, WriteByte, `(':')`)
		_ = HandlerType(ctx, fd.Desc.MapValue().Kind(), f.GeneratedFile, false, "val")
		f.P("}")
		f.P(Buf, WriteByte, "('}')")
		f.WirteCommaTrue(fd, size)
		f.P("}")
	case fd.Desc.Kind() == protoreflect.EnumKind:
		expr := fmt.Sprintf("%s.%s", Instance, fd.GoName)
		if fd.Desc.HasOptionalKeyword() {
			f.P("if ", expr, " != nil {")
			f.WirteCommaAndTrue(fd)
			f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":`)")
			_ = HandlerType(ctx, fd.Desc.Kind(), f.GeneratedFile, false, expr)
			f.WirteCommaTrue(fd, size)
			f.P("}")
		} else {
			f.WirteCommaAndTrue(fd)
			f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":`)")
			_ = HandlerType(ctx, fd.Desc.Kind(), f.GeneratedFile, false, expr)
			f.WirteCommaTrue(fd, size)
		}
	case fd.Desc.Kind() == protoreflect.MessageKind:
		expr, ok := CheckTypeIsDefault(ctx, Instance+"."+fd.GoName, fd)
		if ok {
			f.P("if ", expr, "{")
			f.WirteCommaAndTrue(fd)
			f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":`)")
			_ = HandlerType(ctx, fd.Desc.Kind(), f.GeneratedFile, false, Instance+"."+fd.GoName)
			f.WirteCommaTrue(fd, size)
			f.P("}")
		}
	default:
		if fd.Desc.HasOptionalKeyword() {
			expr := fmt.Sprintf("%s.%s", Instance, fd.GoName)
			f.P("if ", expr, " != nil {")
			f.WirteCommaAndTrue(fd)
			f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":`)")
			_ = HandlerType(ctx, fd.Desc.Kind(), f.GeneratedFile, false, "*"+expr)
			f.WirteCommaTrue(fd, size)
			f.P("}")
		} else if expr, ok := CheckTypeIsDefault(ctx, Instance+"."+fd.GoName, fd); ok {
			f.P("if ", expr, "{")
			f.WirteCommaAndTrue(fd)
			f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":`)")
			_ = HandlerType(ctx, fd.Desc.Kind(), f.GeneratedFile, false, Instance+"."+fd.GoName)
			f.WirteCommaTrue(fd, size)
			f.P("}")
		} else {
			f.WirteCommaAndTrue(fd)
			f.P(Buf, WriteString, "(`\"", fd.Desc.JSONName(), "\":`)")
			_ = HandlerType(ctx, fd.Desc.Kind(), f.GeneratedFile, false, Instance+"."+fd.GoName)
			f.WirteCommaTrue(fd, size)
		}
	}
}

// WirteCommaTrue wirte first filed end set true
func (f *File) WirteCommaTrue(fd *protogen.Field, size int) {
	if fd.Desc.Number() == 1 && size > 1 {
		f.P(CommaVarName, "=true")
	}
}

// GenerateMessageOneof generate oneof field
//
//	return used number
func (f *File) GenerateMessageOneof(ctx *Context, fd *protogen.Field, size int) int {
	f.P("// ", fd.Oneof.GoName, " ", fd.GoName)
	f.P("if ", Instance, ".", fd.Oneof.GoName, " != nil {")
	f.P("switch ", Instance, ":=", Instance, ".", fd.Oneof.GoName, ".(type) {")

	for _, field := range fd.Oneof.Fields {
		f.P("// ", field.GoName, " ", field.GoIdent, " ", field.Desc.Number())
		f.P("case *", field.GoIdent, ":")
		f.GenerateMessageField(ctx, field, size)
		size = int(field.Desc.Number())
	}
	f.P("}")
	f.P("}")
	return size
}

// WirteCommaAndTrue if comma is false change true
func (f *File) WirteCommaAndTrue(fd *protogen.Field) {
	if fd.Desc.Number() > 1 {
		f.P("if ", CommaVarName, " {")
		f.P(Buf, WriteByte, CommaValue)
		f.P("} else {")
		f.P(CommaVarName, "=true")
		f.P("}")
	}
}

// CheckTypeIsDefault 检查 type is default
func CheckTypeIsDefault(_ *Context, val string, fd *protogen.Field) (string, bool) {
	switch fd.Desc.Kind() {
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Uint32Kind,
		protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Uint64Kind,
		protoreflect.Sfixed32Kind, protoreflect.Fixed32Kind,
		protoreflect.Fixed64Kind, protoreflect.Sfixed64Kind,
		protoreflect.DoubleKind, protoreflect.FloatKind:
		return fmt.Sprintf("%v != 0", val), true
	case protoreflect.StringKind, protoreflect.BytesKind:
		return fmt.Sprintf("len(%s) != 0", val), true
	case protoreflect.MessageKind:
		return fmt.Sprintf("%s != nil", val), true
	default:
		return "", false
	}
}
